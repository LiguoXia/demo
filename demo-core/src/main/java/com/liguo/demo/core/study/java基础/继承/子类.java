package com.liguo.demo.core.study.java基础.继承;

import lombok.extern.slf4j.Slf4j;

/**
 * <pre>
 * 父类静态代码块 -> 子类静态代码块 -> 父类构造方法 -> 子类构造方法
 *
 * 1.对象一建立，就会调用与之相应的构造函数，也就是说，不建立对象，构造函数时不会运行的。
 * 2.构造函数的作用是用于给对象进行初始化。
 * 3.一个对象建立，构造函数只运行一次，而一般方法可以被该对象调用多次。
 *
 * 静态代码块：用staitc声明，jvm加载类时执行，仅执行一次
 * 构造代码块：类中直接用{}定义，每一次创建对象时执行。
 * 执行顺序优先级：静态块,main(),构造块,构造方法。
 *
 * 构造函数:
 * 1.对象一建立，就会调用与之相应的构造函数，也就是说，不建立对象，构造函数时不会运行的。
 * 2.构造函数的作用是用于给对象进行初始化。
 * 3.一个对象建立，构造函数只运行一次，而一般方法可以被该对象调用多次。
 *
 * 构造代码块:
 * 1.构造代码块的作用是给对象进行初始化。
 * 2.对象一建立就运行构造代码块了，而且优先于构造函数执行。这里要强调一下，有对象建立，才会运行构造代码块，类不能调用构造代码块的，而且构造代码块与构造函数的执行顺序是前者先于后者执行。
 * 3.构造代码块与构造函数的区别是：构造代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化，因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。
 *
 * 静态代码块:
 * 1.它是随着类的加载而执行，只执行一次，并优先于主函数。具体说，静态代码块是由类调用的。类调用时，先执行静态代码块，然后才执行主函数的。
 * 2.静态代码块其实就是给类初始化的，而构造代码块是给对象初始化的。
 * 3.静态代码块中的变量是局部变量，与普通函数中的局部变量性质没有区别。
 * 4.一个类中可以有多个静态代码块
 *
 *
 * 在 Java 中，如果父类有一个或多个带参数的构造方法，子类需要显式调用其中一个父类的构造方法，因为 Java 不会自动调用父类的带参数构造方法。
 * 以下是具体规则和解释：
 * 1. 默认构造方法的继承关系
 * 如果父类没有定义任何构造方法，编译器会自动生成一个无参构造方法。此时子类可以不显式调用父类构造方法，Java 会默认调用父类的无参构造方法。
 * 但是，如果父类定义了一个带参数的构造方法，编译器不会自动提供无参构造方法。这样，子类必须显式调用父类的一个带参构造方法。
 * 2. 子类调用父类构造方法的方式
 * 子类可以在自己的构造方法中通过 super(...) 调用父类的构造方法。
 * super(...) 必须是子类构造方法的第一行代码，因为在 Java 中，父类的构造方法必须在子类的构造方法执行之前执行。
 *
 * https://www.cnblogs.com/Qian123/p/5713440.html
 * </pre>
 *
 * @author xialiguo0212@gmail.com
 * @version 0.0.1
 * @date 2024/1/16 21:26
 * @since 0.0.1
 */
@Slf4j
public class 子类 extends 父类 {

    static {
        System.out.println("子类静态代码块");
    }

    // 构造代码块
    {
        System.out.println("子类的构造代码块");
    }

    /**
     * Java中规定：在实例化子类对象时(每次都是)，必须先调用父类的构造方法，再调用子类的构造方法（先有父母再有孩子）。且必须在子类构造方法的第一行调用父类方法。
     * 一般在子类中显式的调用父类构造方法，若没有显式调用的调用
     * 则子类会默认调用父类的无参构造方法。（若父类没有无参构造方法，则会编译报错）
     */
    public 子类() {
        System.out.println("子类构造方法");
    }



    /**
     * 如果实例化了一个对象，那么先执行父类的构造方法，然后再执行子类的构造方法
     *
     * @param args
     */
    public static void main(String[] args) {
        父类 f = new 子类();
        //子类 aa = new 子类();
        f.aa("a");
    }

    public void bb() {
        String b = aa("a");
        log.info("", b);
    }
}
